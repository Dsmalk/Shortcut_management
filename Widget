import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog
import os
import requests
import webbrowser
from urllib.parse import urlparse
from PIL import Image, ImageTk
from io import BytesIO

class DesktopWidget:
    def __init__(self, root):
        self.root = root
        self.root.geometry("400x100")
        self.root.title("Widget de Escritorio")
        self.root.configure(bg="#2c2f33")

        self.slots = []  # Lista de espacios donde se agregarán los accesos
        self.slot_data = {}  # Datos asociados a cada slot (espacio)

        # Crear el menú
        self.menu_bar = tk.Menu(self.root)
        self.root.config(menu=self.menu_bar)
        self.menu_bar.add_command(label="Agregar Slot", command=self.add_slot)  # Agregar un nuevo slot
        self.menu_bar.add_command(label="Eliminar Slot", command=self.remove_last_slot)  # Eliminar el último slot

        # Crear el contenedor para los slots
        self.slot_frame = tk.Frame(self.root, bg="#2c2f33")
        self.slot_frame.pack(expand=True, fill="both")

        # Crear los primeros 4 slots
        self.create_initial_slots()

    def create_initial_slots(self):
        for _ in range(4):
            self.add_slot()

    def add_slot(self):
        slot = tk.Frame(self.slot_frame, bg="#23272a", highlightbackground="#7289da", highlightthickness=2)
        slot.pack(side="left", padx=5, pady=15, fill="both", expand=True)

        add_button = tk.Button(slot, text="+", font=("Arial", 30), command=lambda s=slot: self.show_add_options(s))
        add_button.pack(expand=True, fill="both")

        # Hacer que al hacer click derecho en el slot, se muestren opciones
        slot.bind("<Button-3>", lambda event, s=slot: self.show_slot_context_menu(event, s))

        self.slots.append(slot)

    def show_add_options(self, slot):
        """Muestra las opciones para agregar una URL, EXE o Carpeta."""
        option_window = tk.Toplevel(self.root)
        option_window.title("Elegir una opción")
        option_window.geometry("200x150")

        add_url_button = tk.Button(option_window, text="Agregar URL", command=lambda: self.add_url(slot, option_window))
        add_url_button.pack(pady=10)

        add_exe_button = tk.Button(option_window, text="Agregar EXE", command=lambda: self.add_exe(slot, option_window))
        add_exe_button.pack(pady=10)

        add_folder_button = tk.Button(option_window, text="Agregar Carpeta", command=lambda: self.add_folder(slot, option_window))
        add_folder_button.pack(pady=10)

    def add_url(self, slot, option_window):
        """Maneja la adición de una URL."""
        url = simpledialog.askstring("Agregar URL", "Ingresa la URL (por ejemplo, http://youtube.com):", initialvalue="http://")
        if url:
            self.add_to_slot(slot, url, option_window)

    def add_exe(self, slot, option_window):
        """Maneja la adición de un archivo EXE."""
        exe_path = filedialog.askopenfilename(title="Seleccionar EXE", filetypes=[("Archivos Ejecutables", "*.exe")])
        if exe_path:
            self.add_to_slot(slot, exe_path, option_window)

    def add_folder(self, slot, option_window):
        """Maneja la adición de una carpeta."""
        folder_path = filedialog.askdirectory(title="Seleccionar Carpeta")
        if folder_path:
            self.add_to_slot(slot, folder_path, option_window)

    def add_to_slot(self, slot, path, option_window):
        """Agrega el item seleccionado (URL, EXE o Carpeta) al slot."""
        # Limpiar el slot antes de agregar el nuevo contenido
        for widget in slot.winfo_children():
            widget.destroy()

        if "http" in path:
            # Si es una URL, obtenemos el favicon (ícono del sitio web)
            favicon = self.fetch_favicon(path)
            label = tk.Label(slot, text=path, bg="#23272a", fg="white", wraplength=160)
            label.pack(expand=True, fill="both")

            if favicon:
                img = Image.open(BytesIO(favicon))
                img = img.resize((slot.winfo_width(), slot.winfo_height()-20))  # Redimensionar la imagen para que quepa en el slot
                icon = ImageTk.PhotoImage(img)
                icon_label = tk.Label(slot, image=icon, bg="#23272a")
                icon_label.image = icon
                icon_label.pack(expand=True, fill="both")

            # Mostrar el nombre del dominio debajo del ícono
            domain = urlparse(path).netloc
            domain_label = tk.Label(slot, text=domain, bg="#23272a", fg="white", wraplength=160)
            domain_label.pack(expand=True, fill="both")

            # Hacer que al hacer click en el label, se abra la URL
            label.bind("<Button-1>", lambda event, url=path: webbrowser.open(url))
        else:
            # Si es un archivo (EXE) o una carpeta
            label = tk.Label(slot, text=path, bg="#23272a", fg="white", wraplength=160)
            label.pack(expand=True, fill="both")

            # Hacer que al hacer click en el label, se abra la carpeta o el EXE
            label.bind("<Button-1>", lambda event, p=path: self.open_item(p))

        # Agregar el menú de contexto al slot
        label.bind("<Button-3>", lambda event, s=slot, l=label: self.show_context_menu(event, s, l))
        self.slot_data[slot] = path
        option_window.destroy()

    def fetch_favicon(self, url):
        """Obtiene el favicon de una URL."""
        try:
            parsed_url = urlparse(url)
            favicon_url = f"https://www.google.com/s2/favicons?domain={parsed_url.netloc}"
            response = requests.get(favicon_url)

            # Verificar si la respuesta fue exitosa
            if response.status_code == 200:
                return response.content
            else:
                return self.default_favicon()  # Retornar un favicon por defecto si falla la obtención
        except Exception as e:
            print(f"Error al obtener favicon: {e}")
            return self.default_favicon()  # Retornar un favicon por defecto en caso de error

    def default_favicon(self):
        """Retorna un favicon por defecto (un ícono pequeño)."""
        return Image.new('RGB', (16, 16), color='gray').tobytes()

    def open_item(self, path):
        """Abre un archivo (EXE) o carpeta."""
        if os.path.isdir(path):
            os.startfile(path)  # Abrir la carpeta
        else:
            os.startfile(path)  # Abrir el EXE u otro archivo

    def show_context_menu(self, event, slot, label):
        """Muestra el menú de contexto para un slot."""
        context_menu = tk.Menu(self.root, tearoff=0)
        context_menu.add_command(label="Renombrar", command=lambda: self.edit_label(label))
        context_menu.add_command(label="Eliminar", command=lambda: self.remove_item(slot))
        context_menu.tk_popup(event.x_root, event.y_root)

    def show_slot_context_menu(self, event, slot):
        """Muestra el menú de contexto para un slot (click derecho)."""
        context_menu = tk.Menu(self.root, tearoff=0)
        context_menu.add_command(label="Eliminar Slot", command=lambda: self.remove_slot(slot))
        context_menu.tk_popup(event.x_root, event.y_root)

    def edit_label(self, label):
        """Permite renombrar el slot."""
        current_text = label.cget("text")
        label.pack_forget()
        
        entry = tk.Entry(label.master, bg="#23272a", fg="white", justify="center")
        entry.insert(0, current_text)
        entry.pack(expand=True, fill="both")
        
        # Guardar el nuevo nombre al presionar Enter o al salir del campo
        entry.bind("<Return>", lambda event, l=label, e=entry: self.update_label_text(l, e))
        entry.bind("<FocusOut>", lambda event, l=label, e=entry: self.update_label_text(l, e))

    def update_label_text(self, label, entry):
        """Actualiza el texto del label con el nuevo nombre."""
        new_text = entry.get()
        entry.pack_forget()
        label.config(text=new_text)
        label.pack(expand=True, fill="both")

    def remove_item(self, slot):
        """Elimina un item de un slot."""
        if messagebox.askyesno("Confirmar", "¿Querés eliminar este ítem?"):
            for widget in slot.winfo_children():
                widget.destroy()

            add_button = tk.Button(slot, text="+", font=("Arial", 24), command=lambda s=slot: self.show_add_options(s))
            add_button.pack(expand=True, fill="both")

            if slot in self.slot_data:
                del self.slot_data[slot]

    def remove_slot(self, slot):
        """Elimina un slot completo."""
        if slot in self.slots and messagebox.askyesno("Confirmar", "¿Querés eliminar este slot?"):
            for widget in slot.winfo_children():
                widget.destroy()
            slot.destroy()
            self.slots.remove(slot)

    def remove_last_slot(self):
        """Elimina el último slot."""
        if self.slots:
            slot = self.slots[-1]
            self.remove_slot(slot)

if __name__ == "__main__":
    root = tk.Tk()
    app = DesktopWidget(root)
    root.mainloop()
